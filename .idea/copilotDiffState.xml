<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/eslint.config.mjs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/eslint.config.mjs" />
              <option name="originalContent" value="import js from &quot;@eslint/js&quot;;&#10;import { fileURLToPath } from &quot;url&quot;;&#10;import { dirname } from &quot;path&quot;;&#10;import globals from &quot;globals&quot;;&#10;import tsParser from &quot;@typescript-eslint/parser&quot;;&#10;&#10;const __filename = fileURLToPath(import.meta.url);&#10;const __dirname = dirname(__filename);&#10;&#10;export default [&#10;  {&#10;    ignores: [&quot;node_modules/**&quot;, &quot;.next/**&quot;, &quot;out/**&quot;, &quot;build/**&quot;, &quot;next-env.d.ts&quot;]&#10;  },&#10;  js.configs.recommended,&#10;  {&#10;    files: [&quot;**/*.{js,mjs,cjs,ts,mts,cts,jsx,tsx}&quot;],&#10;    languageOptions: {&#10;      parser: tsParser,&#10;      parserOptions: {&#10;        ecmaVersion: &quot;latest&quot;,&#10;        sourceType: &quot;module&quot;,&#10;        ecmaFeatures: {&#10;          jsx: true&#10;        }&#10;      },&#10;      globals: {&#10;        ...globals.browser,&#10;        ...globals.node&#10;      }&#10;    },&#10;    rules: {&#10;      // Keep this minimal so ESLint can load reliably. Add project-specific rules/plugins later.&#10;      // Example: project prefers TypeScript types over prop-types (disabled in source code where needed)&#10;    }&#10;  }&#10;];" />
              <option name="updatedContent" value="import js from &quot;@eslint/js&quot;;&#10;import globals from &quot;globals&quot;;&#10;import tsParser from &quot;@typescript-eslint/parser&quot;;&#10;&#10;&#10;export default [&#10;  {&#10;    ignores: [&quot;node_modules/**&quot;, &quot;.next/**&quot;, &quot;out/**&quot;, &quot;build/**&quot;, &quot;next-env.d.ts&quot;]&#10;  },&#10;  js.configs.recommended,&#10;  {&#10;    files: [&quot;**/*.{js,mjs,cjs,ts,mts,cts,jsx,tsx}&quot;],&#10;    languageOptions: {&#10;      parser: tsParser,&#10;      parserOptions: {&#10;        ecmaVersion: &quot;latest&quot;,&#10;        sourceType: &quot;module&quot;,&#10;        ecmaFeatures: {&#10;          jsx: true&#10;        }&#10;      },&#10;      globals: {&#10;        ...globals.browser,&#10;        ...globals.node&#10;      }&#10;    },&#10;    rules: {&#10;      // Keep this minimal so ESLint can load reliably. Add project-specific rules/plugins later.&#10;      // Example: project prefers TypeScript types over prop-types (disabled in source code where needed)&#10;    }&#10;  }&#10;];" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/lib/rate-limiter.ts">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/lib/rate-limiter.ts" />
              <option name="originalContent" value="export interface RateLimitOptions {&#10;  maxRequests: number;&#10;  windowMs: number;&#10;  minInterval: number;&#10;  maxRetries: number;&#10;  timeoutMs: number;&#10;}&#10;&#10;export class RateLimitError extends Error {&#10;  constructor(message: string, public retryAfter?: number) {&#10;    super(message);&#10;    this.name = 'RateLimitError';&#10;  }&#10;}&#10;&#10;export class TimeoutError extends Error {&#10;  constructor(message: string) {&#10;    super(message);&#10;    this.name = 'TimeoutError';&#10;  }&#10;}&#10;&#10;export class RateLimiter {&#10;  private requests: number[] = [];&#10;  private lastRequest = 0;&#10;  private readonly options: RateLimitOptions;&#10;&#10;  constructor(options: Partial&lt;RateLimitOptions&gt; = {}) {&#10;    this.options = {&#10;      maxRequests: 60, // 60 requests per window&#10;      windowMs: 60 * 1000, // 1 minute window&#10;      minInterval: 1000, // 1 second between requests&#10;      maxRetries: 3,&#10;      timeoutMs: 10000, // 10 second timeout&#10;      ...options,&#10;    };&#10;  }&#10;&#10;  private cleanOldRequests(): void {&#10;    const now = Date.now();&#10;    this.requests = this.requests.filter(&#10;      (timestamp) =&gt; now - timestamp &lt; this.options.windowMs&#10;    );&#10;  }&#10;&#10;  private canMakeRequest(): { allowed: boolean; retryAfter?: number } {&#10;    this.cleanOldRequests();&#10;&#10;    // Check request count limit&#10;    if (this.requests.length &gt;= this.options.maxRequests) {&#10;      const oldestRequest = Math.min(...this.requests);&#10;      const retryAfter = Math.ceil((oldestRequest + this.options.windowMs - Date.now()) / 1000);&#10;      return { allowed: false, retryAfter };&#10;    }&#10;&#10;    // Check minimum interval&#10;    const now = Date.now();&#10;    const timeSinceLastRequest = now - this.lastRequest;&#10;    if (timeSinceLastRequest &lt; this.options.minInterval) {&#10;      const retryAfter = Math.ceil((this.options.minInterval - timeSinceLastRequest) / 1000);&#10;      return { allowed: false, retryAfter };&#10;    }&#10;&#10;    return { allowed: true };&#10;  }&#10;&#10;  private async delay(ms: number): Promise&lt;void&gt; {&#10;    return new Promise((resolve) =&gt; setTimeout(resolve, ms));&#10;  }&#10;&#10;  private async withTimeout&lt;T&gt;(&#10;    promise: Promise&lt;T&gt;,&#10;    timeoutMs: number&#10;  ): Promise&lt;T&gt; {&#10;    const timeoutPromise = new Promise&lt;never&gt;((_, reject) =&gt; {&#10;      setTimeout(() =&gt; {&#10;        reject(new TimeoutError(`Request timed out after ${timeoutMs}ms`));&#10;      }, timeoutMs);&#10;    });&#10;&#10;    return Promise.race([promise, timeoutPromise]);&#10;  }&#10;&#10;  private async exponentialBackoff(attempt: number): Promise&lt;void&gt; {&#10;    const baseDelay = 1000; // 1 second&#10;    const maxDelay = 30000; // 30 seconds&#10;    const delay = Math.min(baseDelay * Math.pow(2, attempt), maxDelay);&#10;    const jitter = Math.random() * 0.1 * delay; // Add 10% jitter&#10;    &#10;    await this.delay(delay + jitter);&#10;  }&#10;&#10;  async execute&lt;T&gt;(fn: () =&gt; Promise&lt;T&gt;): Promise&lt;T&gt; {&#10;    let lastError: Error | null = null;&#10;&#10;    for (let attempt = 0; attempt &lt;= this.options.maxRetries; attempt++) {&#10;      try {&#10;        // Check rate limit&#10;        const { allowed, retryAfter } = this.canMakeRequest();&#10;        if (!allowed) {&#10;          if (retryAfter &amp;&amp; retryAfter &lt;= 60) { // Only wait if retry time is reasonable&#10;            await this.delay(retryAfter * 1000);&#10;          } else {&#10;            throw new RateLimitError(&#10;              `Rate limit exceeded. Try again in ${retryAfter} seconds.`,&#10;              retryAfter&#10;            );&#10;          }&#10;        }&#10;&#10;        // Record request&#10;        const now = Date.now();&#10;        this.requests.push(now);&#10;        this.lastRequest = now;&#10;&#10;        // Execute with timeout&#10;        const result = await this.withTimeout(fn(), this.options.timeoutMs);&#10;        return result;&#10;&#10;      } catch (error) {&#10;        lastError = error as Error;&#10;&#10;        // Don't retry on certain types of errors&#10;        if (&#10;          error instanceof TimeoutError ||&#10;          error instanceof RateLimitError ||&#10;          (error instanceof Error &amp;&amp; 'status' in error &amp;&amp; &#10;            (error.status === 401 || error.status === 403 || error.status === 404))&#10;        ) {&#10;          throw error;&#10;        }&#10;&#10;        // Don't retry on last attempt&#10;        if (attempt === this.options.maxRetries) {&#10;          break;&#10;        }&#10;&#10;        // Apply exponential backoff before retry&#10;        await this.exponentialBackoff(attempt);&#10;      }&#10;    }&#10;&#10;    throw lastError || new Error('All retry attempts failed');&#10;  }&#10;&#10;  getStats(): {&#10;    recentRequests: number;&#10;    windowMs: number;&#10;    canMakeRequest: boolean;&#10;    nextAvailableTime?: Date;&#10;  } {&#10;    this.cleanOldRequests();&#10;    const { allowed, retryAfter } = this.canMakeRequest();&#10;&#10;    return {&#10;      recentRequests: this.requests.length,&#10;      windowMs: this.options.windowMs,&#10;      canMakeRequest: allowed,&#10;      nextAvailableTime: retryAfter &#10;        ? new Date(Date.now() + retryAfter * 1000)&#10;        : undefined,&#10;    };&#10;  }&#10;}&#10;&#10;// Global rate limiter instance for Octopus Energy API&#10;export const octopusApiRateLimiter = new RateLimiter({&#10;  maxRequests: 30, // Conservative limit for Octopus Energy API&#10;  windowMs: 60 * 1000, // 1 minute window&#10;  minInterval: 2000, // 2 seconds between requests&#10;  maxRetries: 3,&#10;  timeoutMs: 15000, // 15 second timeout&#10;});" />
              <option name="updatedContent" value="export interface RateLimitOptions {&#13;&#10;  maxRequests: number;&#13;&#10;  windowMs: number;&#13;&#10;  minInterval: number;&#13;&#10;  maxRetries: number;&#13;&#10;  timeoutMs: number;&#13;&#10;}&#13;&#10;&#13;&#10;export class RateLimitError extends Error {&#13;&#10;  public retryAfter?: number;&#13;&#10;  constructor(message: string, retryAfter?: number) {&#13;&#10;    super(message);&#13;&#10;    this.name = 'RateLimitError';&#13;&#10;    this.retryAfter = retryAfter;&#13;&#10;  }&#13;&#10;}&#13;&#10;&#13;&#10;export class TimeoutError extends Error {&#13;&#10;  constructor(message: string) {&#13;&#10;    super(message);&#13;&#10;    this.name = 'TimeoutError';&#13;&#10;  }&#13;&#10;}&#13;&#10;&#13;&#10;export class RateLimiter {&#13;&#10;  private requests: number[] = [];&#13;&#10;  private lastRequest = 0;&#13;&#10;  private readonly options: RateLimitOptions;&#13;&#10;&#13;&#10;  constructor(options: Partial&lt;RateLimitOptions&gt; = {}) {&#13;&#10;    this.options = {&#13;&#10;      maxRequests: 60, // 60 requests per window&#13;&#10;      windowMs: 60 * 1000, // 1 minute window&#13;&#10;      minInterval: 1000, // 1 second between requests&#13;&#10;      maxRetries: 3,&#13;&#10;      timeoutMs: 10000, // 10 second timeout&#13;&#10;      ...options,&#13;&#10;    };&#13;&#10;  }&#13;&#10;&#13;&#10;  private cleanOldRequests(): void {&#13;&#10;    const now = Date.now();&#13;&#10;    this.requests = this.requests.filter(&#13;&#10;      (timestamp) =&gt; now - timestamp &lt; this.options.windowMs&#13;&#10;    );&#13;&#10;  }&#13;&#10;&#13;&#10;  private canMakeRequest(): { allowed: boolean; retryAfter?: number } {&#13;&#10;    this.cleanOldRequests();&#13;&#10;&#13;&#10;    // Check request count limit&#13;&#10;    if (this.requests.length &gt;= this.options.maxRequests) {&#13;&#10;      const oldestRequest = Math.min(...this.requests);&#13;&#10;      const retryAfter = Math.ceil((oldestRequest + this.options.windowMs - Date.now()) / 1000);&#13;&#10;      return { allowed: false, retryAfter };&#13;&#10;    }&#13;&#10;&#13;&#10;    // Check minimum interval&#13;&#10;    const now = Date.now();&#13;&#10;    const timeSinceLastRequest = now - this.lastRequest;&#13;&#10;    if (timeSinceLastRequest &lt; this.options.minInterval) {&#13;&#10;      const retryAfter = Math.ceil((this.options.minInterval - timeSinceLastRequest) / 1000);&#13;&#10;      return { allowed: false, retryAfter };&#13;&#10;    }&#13;&#10;&#13;&#10;    return { allowed: true };&#13;&#10;  }&#13;&#10;&#13;&#10;  private async delay(ms: number): Promise&lt;void&gt; {&#13;&#10;    return new Promise((resolve) =&gt; setTimeout(resolve, ms));&#13;&#10;  }&#13;&#10;&#13;&#10;  private async withTimeout&lt;T&gt;(&#13;&#10;    promise: Promise&lt;T&gt;,&#13;&#10;    timeoutMs: number&#13;&#10;  ): Promise&lt;T&gt; {&#13;&#10;    const timeoutPromise = new Promise&lt;never&gt;((_, reject) =&gt; {&#13;&#10;      setTimeout(() =&gt; {&#13;&#10;        reject(new TimeoutError(`Request timed out after ${timeoutMs}ms`));&#13;&#10;      }, timeoutMs);&#13;&#10;    });&#13;&#10;&#13;&#10;    return Promise.race([promise, timeoutPromise]);&#13;&#10;  }&#13;&#10;&#13;&#10;  private async exponentialBackoff(attempt: number): Promise&lt;void&gt; {&#13;&#10;    const baseDelay = 1000; // 1 second&#13;&#10;    const maxDelay = 30000; // 30 seconds&#13;&#10;    const delay = Math.min(baseDelay * Math.pow(2, attempt), maxDelay);&#13;&#10;    const jitter = Math.random() * 0.1 * delay; // Add 10% jitter&#13;&#10;    &#13;&#10;    await this.delay(delay + jitter);&#13;&#10;  }&#13;&#10;&#13;&#10;  async execute&lt;T&gt;(fn: () =&gt; Promise&lt;T&gt;): Promise&lt;T&gt; {&#13;&#10;    let lastError: Error | null = null;&#13;&#10;&#13;&#10;    for (let attempt = 0; attempt &lt;= this.options.maxRetries; attempt++) {&#13;&#10;      try {&#13;&#10;        // Check rate limit&#13;&#10;        const { allowed, retryAfter } = this.canMakeRequest();&#13;&#10;        if (!allowed) {&#13;&#10;          if (retryAfter &amp;&amp; retryAfter &lt;= 60) { // Only wait if retry time is reasonable&#13;&#10;            await this.delay(retryAfter * 1000);&#13;&#10;          } else {&#13;&#10;            throw new RateLimitError(&#13;&#10;              `Rate limit exceeded. Try again in ${retryAfter} seconds.`,&#13;&#10;              retryAfter&#13;&#10;            );&#13;&#10;          }&#13;&#10;        }&#13;&#10;&#13;&#10;        // Record request&#13;&#10;        const now = Date.now();&#13;&#10;        this.requests.push(now);&#13;&#10;        this.lastRequest = now;&#13;&#10;&#13;&#10;        // Execute with timeout&#13;&#10;        const result = await this.withTimeout(fn(), this.options.timeoutMs);&#13;&#10;        return result;&#13;&#10;&#13;&#10;      } catch (error) {&#13;&#10;        lastError = error as Error;&#13;&#10;&#13;&#10;        // Don't retry on certain types of errors&#13;&#10;        if (&#13;&#10;          error instanceof TimeoutError ||&#13;&#10;          error instanceof RateLimitError ||&#13;&#10;          (error instanceof Error &amp;&amp; 'status' in error &amp;&amp; &#13;&#10;            (error.status === 401 || error.status === 403 || error.status === 404))&#13;&#10;        ) {&#13;&#10;          throw error;&#13;&#10;        }&#13;&#10;&#13;&#10;        // Don't retry on last attempt&#13;&#10;        if (attempt === this.options.maxRetries) {&#13;&#10;          break;&#13;&#10;        }&#13;&#10;&#13;&#10;        // Apply exponential backoff before retry&#13;&#10;        await this.exponentialBackoff(attempt);&#13;&#10;      }&#13;&#10;    }&#13;&#10;&#13;&#10;    throw lastError || new Error('All retry attempts failed');&#13;&#10;  }&#13;&#10;&#13;&#10;  getStats(): {&#13;&#10;    recentRequests: number;&#13;&#10;    windowMs: number;&#13;&#10;    canMakeRequest: boolean;&#13;&#10;    nextAvailableTime?: Date;&#13;&#10;  } {&#13;&#10;    this.cleanOldRequests();&#13;&#10;    const { allowed, retryAfter } = this.canMakeRequest();&#13;&#10;&#13;&#10;    return {&#13;&#10;      recentRequests: this.requests.length,&#13;&#10;      windowMs: this.options.windowMs,&#13;&#10;      canMakeRequest: allowed,&#13;&#10;      nextAvailableTime: retryAfter &#13;&#10;        ? new Date(Date.now() + retryAfter * 1000)&#13;&#10;        : undefined,&#13;&#10;    };&#13;&#10;  }&#13;&#10;}&#13;&#10;&#13;&#10;// Global rate limiter instance for Octopus Energy API&#13;&#10;export const octopusApiRateLimiter = new RateLimiter({&#13;&#10;  maxRequests: 30, // Conservative limit for Octopus Energy API&#13;&#10;  windowMs: 60 * 1000, // 1 minute window&#13;&#10;  minInterval: 2000, // 2 seconds between requests&#13;&#10;  maxRetries: 3,&#13;&#10;  timeoutMs: 15000, // 15 second timeout&#13;&#10;});" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/lib/validation.ts">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/lib/validation.ts" />
              <option name="originalContent" value="import { EnergyRate, ApiResponse } from './types';&#10;&#10;export class ValidationError extends Error {&#10;  constructor(message: string, public field?: string) {&#10;    super(message);&#10;    this.name = 'ValidationError';&#10;  }&#10;}&#10;&#10;export const ValidationRules = {&#10;  days: {&#10;    min: 1,&#10;    max: 30,&#10;    default: 3,&#10;  },&#10;  api: {&#10;    maxRetries: 3,&#10;    timeoutMs: 10000,&#10;    maxResults: 1500,&#10;  }&#10;} as const;&#10;&#10;export function validateDaysParameter(value: string | undefined): number {&#10;  const { min, max, default: defaultValue } = ValidationRules.days;&#10;  &#10;  if (!value || value.trim() === '') {&#10;    return defaultValue;&#10;  }&#10;  &#10;  const parsed = parseInt(value, 10);&#10;  &#10;  if (isNaN(parsed)) {&#10;    throw new ValidationError(&#10;      `Invalid days parameter: &quot;${value}&quot;. Must be a number between ${min} and ${max}.`,&#10;      'days'&#10;    );&#10;  }&#10;  &#10;  if (parsed &lt; min || parsed &gt; max) {&#10;    throw new ValidationError(&#10;      `Days parameter out of range: ${parsed}. Must be between ${min} and ${max}.`,&#10;      'days'&#10;    );&#10;  }&#10;  &#10;  return parsed;&#10;}&#10;&#10;export function validateEnergyRate(data: unknown): data is EnergyRate {&#10;  if (typeof data !== 'object' || data === null) {&#10;    return false;&#10;  }&#10;  &#10;  const rate = data as Record&lt;string, unknown&gt;;&#10;  &#10;  return (&#10;    typeof rate.value_exc_vat === 'number' &amp;&amp;&#10;    typeof rate.value_inc_vat === 'number' &amp;&amp;&#10;    typeof rate.valid_from === 'string' &amp;&amp;&#10;    typeof rate.valid_to === 'string' &amp;&amp;&#10;    !isNaN(Date.parse(rate.valid_from)) &amp;&amp;&#10;    !isNaN(Date.parse(rate.valid_to)) &amp;&amp;&#10;    rate.value_inc_vat &gt;= -100 &amp;&amp; // Reasonable bounds&#10;    rate.value_inc_vat &lt;= 1000&#10;  );&#10;}&#10;&#10;export function validateApiResponse(data: unknown): data is ApiResponse {&#10;  if (typeof data !== 'object' || data === null) {&#10;    return false;&#10;  }&#10;  &#10;  const response = data as Record&lt;string, unknown&gt;;&#10;  &#10;  return (&#10;    typeof response.count === 'number' &amp;&amp;&#10;    (response.next === null || typeof response.next === 'string') &amp;&amp;&#10;    (response.previous === null || typeof response.previous === 'string') &amp;&amp;&#10;    Array.isArray(response.results) &amp;&amp;&#10;    response.results.every(validateEnergyRate)&#10;  );&#10;}&#10;&#10;export function sanitizeSearchParams(params: Record&lt;string, string | string[] | undefined&gt;): {&#10;  days: number;&#10;} {&#10;  const daysParam = Array.isArray(params.days) ? params.days[0] : params.days;&#10;  &#10;  try {&#10;    const days = validateDaysParameter(daysParam);&#10;    return { days };&#10;  } catch (error) {&#10;    if (error instanceof ValidationError) {&#10;      console.warn(`Search parameter validation failed: ${error.message}`);&#10;      return { days: ValidationRules.days.default };&#10;    }&#10;    throw error;&#10;  }&#10;}&#10;&#10;export function validateUrl(url: string): boolean {&#10;  try {&#10;    const parsed = new URL(url);&#10;    return parsed.protocol === 'https:' &amp;&amp; parsed.hostname === 'api.octopus.energy';&#10;  } catch {&#10;    return false;&#10;  }&#10;}" />
              <option name="updatedContent" value="import { EnergyRate, ApiResponse } from './types';&#10;&#10;export class ValidationError extends Error {&#10;  public field?: string;&#10;  constructor(message: string, field?: string) {&#10;    super(message);&#10;    this.name = 'ValidationError';&#10;    this.field = field;&#10;  }&#10;}&#10;&#10;export const ValidationRules = {&#10;  days: {&#10;    min: 1,&#10;    max: 30,&#10;    default: 3,&#10;  },&#10;  api: {&#10;    maxRetries: 3,&#10;    timeoutMs: 10000,&#10;    maxResults: 1500,&#10;  }&#10;} as const;&#10;&#10;export function validateDaysParameter(value: string | undefined): number {&#10;  const { min, max, default: defaultValue } = ValidationRules.days;&#10;  &#10;  if (!value || value.trim() === '') {&#10;    return defaultValue;&#10;  }&#10;  &#10;  const parsed = parseInt(value, 10);&#10;  &#10;  if (isNaN(parsed)) {&#10;    throw new ValidationError(&#10;      `Invalid days parameter: &quot;${value}&quot;. Must be a number between ${min} and ${max}.`,&#10;      'days'&#10;    );&#10;  }&#10;  &#10;  if (parsed &lt; min || parsed &gt; max) {&#10;    throw new ValidationError(&#10;      `Days parameter out of range: ${parsed}. Must be between ${min} and ${max}.`,&#10;      'days'&#10;    );&#10;  }&#10;  &#10;  return parsed;&#10;}&#10;&#10;export function validateEnergyRate(data: unknown): data is EnergyRate {&#10;  if (typeof data !== 'object' || data === null) {&#10;    return false;&#10;  }&#10;  &#10;  const rate = data as Record&lt;string, unknown&gt;;&#10;  &#10;  return (&#10;    typeof rate.value_exc_vat === 'number' &amp;&amp;&#10;    typeof rate.value_inc_vat === 'number' &amp;&amp;&#10;    typeof rate.valid_from === 'string' &amp;&amp;&#10;    typeof rate.valid_to === 'string' &amp;&amp;&#10;    !isNaN(Date.parse(rate.valid_from)) &amp;&amp;&#10;    !isNaN(Date.parse(rate.valid_to)) &amp;&amp;&#10;    rate.value_inc_vat &gt;= -100 &amp;&amp; // Reasonable bounds&#10;    rate.value_inc_vat &lt;= 1000&#10;  );&#10;}&#10;&#10;export function validateApiResponse(data: unknown): data is ApiResponse {&#10;  if (typeof data !== 'object' || data === null) {&#10;    return false;&#10;  }&#10;  &#10;  const response = data as Record&lt;string, unknown&gt;;&#10;  &#10;  return (&#10;    typeof response.count === 'number' &amp;&amp;&#10;    (response.next === null || typeof response.next === 'string') &amp;&amp;&#10;    (response.previous === null || typeof response.previous === 'string') &amp;&amp;&#10;    Array.isArray(response.results) &amp;&amp;&#10;    response.results.every(validateEnergyRate)&#10;  );&#10;}&#10;&#10;export function sanitizeSearchParams(params: Record&lt;string, string | string[] | undefined&gt;): {&#10;  days: number;&#10;} {&#10;  const daysParam = Array.isArray(params.days) ? params.days[0] : params.days;&#10;  &#10;  try {&#10;    const days = validateDaysParameter(daysParam);&#10;    return { days };&#10;  } catch (error) {&#10;    if (error instanceof ValidationError) {&#10;      console.warn(`Search parameter validation failed: ${error.message}`);&#10;      return { days: ValidationRules.days.default };&#10;    }&#10;    throw error;&#10;  }&#10;}&#10;&#10;export function validateUrl(url: string): boolean {&#10;  try {&#10;    const parsed = new URL(url);&#10;    return parsed.protocol === 'https:' &amp;&amp; parsed.hostname === 'api.octopus.energy';&#10;  } catch {&#10;    return false;&#10;  }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>